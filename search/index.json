[{"content":"便利な書き方 Map と Entry The Rust Programming Language - Storing Keys with Associated Values in Hash Maps use std::collections::HashMap; let mut counter: HashMap\u0026lt;u32, usize\u0026gt; = HashMap::default(); counter.entry(1).or_insert(1); assert_eq!(counter[\u0026amp;1], 1); counter.entry(1).or_insert(10); assert_eq!(counter[\u0026amp;1], 1); counter.entry(2).or_default(); assert_eq!(counter[\u0026amp;2], 0); // or_insert と or_insert_with の違いを見る let mut a = 5; let f = |n: \u0026amp;mut usize| { *n += 1; *n }; counter.entry(3).or_insert_with(|| f(\u0026amp;mut a)); assert_eq!(counter[\u0026amp;3], 6); counter.entry(4).or_insert(f(\u0026amp;mut a)); assert_eq!(counter[\u0026amp;4], 7); counter.entry(5).or_insert_with(|| f(\u0026amp;mut a)); assert_eq!(a, 8); counter.entry(5).or_insert_with(|| f(\u0026amp;mut a)); // `f` is not executed here. assert_eq!(a, 8); counter.entry(5).or_insert(f(\u0026amp;mut a)); // `f` is executed here. assert_eq!(a, 9); assert_eq!(counter[\u0026amp;5], 8); if let と while let The Rust Programming Language - if let The Rust Programming Language - while let // N: 頂点数, graph: Vec\u0026lt;Vec\u0026lt;usize\u0026gt;\u0026gt; の隣接リスト での幅優先探索 let mut seen = vec![false; N]; let mut dist = vec![usize::MAX; N]; let mut q = std::collections::VecDeque::new(); let src = 0; q.push_back(src); seen[src] = true; dist[src] = 0; while let Some(u) = q.pop_front() { for \u0026amp;v in graph[u].iter() { if seen[v] { continue; } q.push_back(v); seen[v] = true; dist[v] = dist[u] + 1; } } ラベル付きの break Rust By Example - Nesting and labels Rust By Example - Returning from loops let N = 1000; let mut isok = false; \u0026#39;OUTER: for i in 0..N { for j in 0..N { isok |= hoge(i, j); if isok { break \u0026#39;OUTER; } } } // よくある書き方 // for i in 0..N { // for j in 0..N { // isok |= hoge(i, j); // if isok { // break; // } // } // if isok { // break; // } // } 少しだけ実行時間制限を超過するときにできること FxHashMap, FxHashSetの利用 Rustがデフォルトで使用するアルゴリズムよりも高速なハッシュアルゴリズムを使用した HashMap を利用する。 rustc-hash ABC339 G - Smaller Sum では動的2次元Binary Indexed Treeを使った解法において、FxHashMapを使うとACできた。 FxHashMapを使った提出 3450ms FxHashMapを使わない提出 TLE use rustc_hash::FxHashMap; let mut map: FxHashMap\u0026lt;u32, char\u0026gt; = FxHashMap::default(); map.insert(1, \u0026#39;b\u0026#39;); 2次元の vector を1次元にする $H$ 行 $W$ 列の行列を $H \\times W$ 個の要素の vector に変換するような状況では、1次元化するのと一緒に以下のような関数を書いておくと、少し便利になる。 2次元座標を1次元座標に変換する let flatten = |y: usize, x: usize| y * W + x; 1次元座標を2次元座標に変換する let unflatten = |p: usize| (p / W, p % W); ミスを減らすために {}を上手に使う 下記のように、{} を上手く使うとミスを減らせる。\n可変性が必要な場所だけ可変にできる 繰り返し同じ名前の変数を使うときに初期化を忘れるといった凡ミスを防止できる proconio::input! {N: usize, M: usize, edges: [(Usize1, Usize1); M]} let graph = { let mut g = vec![vec![]; N]; for (u, v) in edges { g[u].push(v); g[v].push(u); } g }; ","date":"2024-08-05T14:47:21.59Z","permalink":"https://naut3.github.io/p/tips/","title":"💡Tips"},{"content":"AtCoder Beginner Contest 365 コンテストページ\n23分40秒で5完して、468位でした。 A問題 うるう年の条件が問題文で与えられるので、西暦 $Y$ 年の日数を求めてください。 問題文通りに実装すれば OKです。 B問題 長さ $N$ の相異なる項からなる数列 $A$ が与えられます。$A$ の中で $2$番目に大きい要素は何番目の要素かを求めてください。 上手くやれば $O(N)$ でもできますが、$N \\leq 100$ なので、$A$をソートした配列$B$の後ろから二番目の要素と一致するもののインデックスを出力すればよいです。 ここからは少し丁寧に振り返ります。\nC問題 問題概要 $N$ 人がイベントに参加し、それぞれ交通費が$A_i$円かかります。 交通費の補助額を上限$x$円と設定し、人$i$には$\\min{(x, A_i)}$を支給します。 予算が$M$円なので、$N$人に渡す補助額の総和を$M$円以下にしたいです。 $x$を最大で何円にできるかを求めてください。ただし、上限が存在しない場合、そのことを出力します。 $N \\leq 2 \\times 10^{5}, M \\leq 2 \\times 10^{14}$ 考えたこと まず、上限が無限に大きくできるときは、どのような条件が成り立つかを考えます。\n$x \\geq \\max{A_i}$ を満たす$x$では、補助額の総和は同じです。したがって、$x = \\max{A_i}$ のとき予算をオーバーしないなら、上限は存在しません。また、同様に上限が存在するなら必ず、$x \u0026lt; \\max{A_i}$が成り立ちます。\n上限が存在し、それを$m$であるとします。$[0, \\max{A_i})$の範囲で二分探索を行えば、補助額の総和が$M$円以下の補助額の上限値の最大値は、$m$と一致します。したがって、$O(N \\log{\\max{A_i}})$ で答えが計算できます。\nD問題 問題概要 2人のプレイヤーがじゃんけんをします。相手が出した手を事前に知っていて、それは$S = S_1 S_2 \\dots S_N$で表されます。 私は、以下の条件を満たすように手を出す必要があります。それを満たすような手の列の内、じゃんけんで勝った回数の最大値を計算してください。 私は一度もじゃんけんに負けない。 私が$i$回目に出す手と$i + 1$回目に出す手は異なる。 $N \\leq 2 \\times 10^{5}$ 考えたこと 1手目から順に出す手を決めていくとします。このとき、$i$手目を制限するのは、相手の手と自分が$i - 1$手目だけです。\nそこで、$i$ 手目がグー、チョキ、パーそれぞれでの勝った回数の最大値が計算できれば$i + 1$手目でグー、チョキ、パーそれぞれでの勝った回数の最大値が計算できます。\nこれは適当な動的計画法で$O(N)$で可能です。提出コード\nE問題 問題概要 長さ$N$の数列$A = (A_1, A_2, \\dots, A_N)$が与えられます。以下の値を計算してください。 $$ \\sum_{i = 1}^{N - 1} \\sum_{j = i + 1}^{N} {A_i \\oplus A_{i + 1} \\oplus \\dots \\oplus A_{j}} $$\n$N \\leq 2\\times 10^{5}, 1 \\leq A_i \\leq 10^{8}$ 考えたこと まず、各bit毎に考え、それらを後から合算して答えを計算することにします。\n$i$ bit 目を取り出して $B_1, B_2, B_3, \\dots, B_N (B_j = 0, 1)$とします。\n$k$ 項目を右端とするような部分排他的論理和について考えます。きちんと列挙すると、$\\oplus_{i=1}^{k} B_i, \\oplus_{i=2}^{k} B_i, \\dots, \\oplus_{i=k-1}^{k} B_i$のように書けます。\n同様に、$k + 1$ 項目を右端とするような部分排他的論理和について考えます。きちんと列挙すると、$\\oplus_{i=1}^{k+1} B_i, \\oplus_{i=2}^{k+1} B_i, \\dots, \\oplus_{i=k}^{k+1} B_i$のように書けます。\nそれぞれ $S_k, S_{k + 1}$ とします。$S_{k + 1} = \\lbrace a \\oplus B_{k+1} | a \\in S_k \\rbrace \\cup \\lbrace B_k \\oplus B_{k + 1} \\rbrace$ が成り立ちます。(重複した値も別々に考えています)\nこれら部分排他的論理和は当然 $0, 1$ のいずれかしか取らないので、$\\text{dp} \\lbrack i \\rbrack \\lbrack T | F \\rbrack$ を$i$項目を右端とする部分排他的論理和で$T, F$の数であるとするような動的計画法によって、$O(N)$ で計算できます。答えは$\\displaystyle \\sum_{i} \\text{dp} \\lbrack i \\rbrack \\lbrack T \\rbrack$ です。単一項の部分和の処理によって、少し変わる場合がありますが、適当に補正すればよいです。\nこれで、全体で$O(N \\log{A})$ で答えを計算でき、これは十分実行時間制限に間に合います。提出コード\n","date":"2024-08-04T13:45:05.01Z","permalink":"https://naut3.github.io/p/abc365-%E6%84%9F%E6%83%B3%E6%8C%AF%E3%82%8A%E8%BF%94%E3%82%8A/","title":"ABC365 感想・振り返り"},{"content":"見出し2 見出し3 見出し4 インライン数式が書ける。 $\\displaystyle\\sum_{i = 1}^{n} i = \\frac{n(n + 1)}{2}$\n箇条書きのところでも書ける。 $e^{i \\pi} + 1 = 0$ ディスプレイ数式モードでも数式を書ける。\n$$ f(x) = \\frac{1}{\\sqrt{2 \\pi \\sigma^{2}}} \\exp{\\left( -\\frac{(x - \\mu)^2}{2 \\sigma^2} \\right)} $$\nコードブロックもある。インライン表示は右の通り。println!(\u0026quot;Hello World!\u0026quot;)\nlet mut a = 5; let b = 4; a += 1; assert_eq!(a + b, 10); リンク\n","date":"2024-08-04T13:12:32.142Z","permalink":"https://naut3.github.io/p/%E3%83%86%E3%82%B9%E3%83%88%E3%83%9A%E3%83%BC%E3%82%B8/","title":"テストページ"}]